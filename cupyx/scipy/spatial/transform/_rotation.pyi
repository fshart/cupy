from __future__ import annotations
from typing import TYPE_CHECKING, Union, Sequence
import cupy as cp

if TYPE_CHECKING:
    import cupy.typing as cpt

_IntegerType = Union[int, cp.integer]


class Rotation:
    def __init__(self, quat: cpt.ArrayLike, normalize: bool = ..., copy: bool = ...) -> None: ...
    @property
    def single(self) -> bool: ...
    def __len__(self) -> int: ...
    @classmethod
    def from_quat(cls, quat: cpt.ArrayLike) -> Rotation: ...
    @classmethod
    def from_matrix(cls, matrix: cpt.ArrayLike) -> Rotation: ...
    @classmethod
    def from_rotvec(cls, rotvec: cpt.ArrayLike, degrees: bool = ...) -> Rotation: ...
    @classmethod
    def from_euler(cls, seq: str, angles: float | cpt.ArrayLike, degrees: bool = ...) -> Rotation: ...
    @classmethod
    def from_mrp(cls, mrp: cpt.ArrayLike) -> Rotation: ...
    def as_quat(self, canonical: bool) -> cp.ndarray: ...
    def as_matrix(self) -> cp.ndarray: ...
    def as_rotvec(self, degrees: bool = ...) -> cp.ndarray: ...
    def as_euler(self, seq: str, degrees: bool = ...) -> cp.ndarray: ...
    def as_mrp(self) -> cp.ndarray: ...
    @classmethod
    def concatenate(cls, rotations: Sequence[Rotation]) -> Rotation: ...
    def apply(self, vectors: cpt.ArrayLike, inverse: bool = ...) -> cp.ndarray: ...
    def __mul__(self, other: Rotation) -> Rotation: ...
    def __pow__(self, n: float, modulus: int | None) -> Rotation: ...
    def inv(self) -> Rotation: ...
    def magnitude(self) -> cp.ndarray | float: ...
    def approx_equal(self, other: Rotation, atol: float | None, degrees: bool = ...) -> cp.ndarray | bool: ...
    def mean(self, weights: cpt.ArrayLike | None = ...) -> Rotation: ...
    def reduce(self, left: Rotation | None = ..., right: Rotation | None = ...,
               return_indices: bool = ...) -> Rotation | tuple[Rotation, cp.ndarray, cp.ndarray]: ...
    @classmethod
    def create_group(cls, group: str, axis: str = ...) -> Rotation: ...
    def __getitem__(self, indexer: int | slice | cpt.ArrayLike) -> Rotation: ...
    @classmethod
    def identity(cls, num: int | None = ...) -> Rotation: ...
#     @classmethod
#     def random(cls, num: int | None = ...,
#                random_state: _IntegerType | cp.random.Generator | cp.random.RandomState | None = ...) -> Rotation: ...
    @classmethod
    def align_vectors(cls, a: cpt.ArrayLike, b: cpt.ArrayLike,
                      weights: cpt.ArrayLike | None = ...,
                      return_sensitivity: bool = ...) -> tuple[Rotation, float] | tuple[Rotation, float, cp.ndarray]:...

class Slerp:
    times: cp.ndarray
    timedelta: cp.ndarray
    rotations: Rotation
    rotvecs: cp.ndarray
    def __init__(self, times: cpt.ArrayLike, rotations: Rotation) -> None: ...
    def __call__(self, times: cpt.ArrayLike) -> Rotation: ...
